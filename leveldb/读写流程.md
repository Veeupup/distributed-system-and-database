[TOC]

# Put

作用：将指定的一个 KV 存储到 leveldb 中

过程（重要的步骤说明）：

* `DBImpl::Put(const WriteOptions& o, const Slice& key, const Slice& val)` 
  * 用户调用接口，会调用 
* `DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value)`
  * 这里会将单个的 Write 也改写成 WriteBatch 的形式，然后调用 `Write` 接口，`Write ` 接口是统一 leveldb 统一写操作的接口
* `DBImpl::Write(const WriteOptions& options, WriteBatch* updates)`
  * 会将写操作封装成一个 Writer 对象，然后这个地方会获取到一个 mutex lock，然后将当前的 Writer 加入到一个 deque 中去，由于拿到了 mutex，所以是**并发安全**的，这个入队列的操作是很快的，不需要真的写入
  * 很多 Writer 入队列之后都被加入到了末尾，所以这个这个循环条件是成立的，直到某个队列头的 Writer 出队列
  * 这个时候在 写队列头的 Writer 将负责这次写（这个 **首当其冲**的 Writer 任重道远）
    * 首先将调用 `MakeRoomForWrite`，检查 memtable 是否有足够的空间来写，可能有很多检查，例如当前是不是写的太快（是不是太多的 L0 文件，当前 memtable 没有足够空间且 immutable memtable 存在，甚至可能会手动调用 compaction），直到有一个足够空间的 memtable 来写
    * 调用 `BuildBatchGroup` 来将很多小的写入合成一个大的，这个很有讲究，因为不仅仅是将根据小的Writer 请求加起来的大小超过某个数值才写，还要看写入是否是 sync 的写入，如果是 sync 的写入，那么将直接写，因为要让用户马上返回不阻塞太久（不等别人），这个时候一些 non-sync 的 Writer 甚至可以搭上便车马上写入，但是如果一个非 sync 操作被搭车到一个 sync 操作的批次中，会使这个非 sync 的操作的延时给拖高。所以非同步的写要比同步的写快上几乎 1000 倍
    * 然后就是 `AddRecord` 写入，这个是写入到 log 中，详细看这个函数可以看到会将所有的数据分 block 来写，可以参考 https://leveldb-handbook.readthedocs.io/zh/latest/sstable.html#id2 来看对应的 data block 的接口，这里会实际的物理刷盘，WAL
    * 调用 `WriteBatchInternal::InsertInto(write_batch, mem_)`，写入到 memtable 中去，这是调表的插入，不在这里赘述，在 memtable 中看 skiplist 的读写
    * 设定 `Sequence`，这是用于 MVCC 的属性，`SequenceNumber` 是单调增加的，相当于一个本地的单调时钟，可以给所有的操作排序，这是一个非常非常重要的保证
    * 负责将当前此次 WriteBatch 中的一条船上的 Writer 的 done 修改为 true，同时来唤醒他们，让他们都出队列，让下一个 **首当其冲** 的 Writer 来负责下一个写的重任（要带着兄弟萌一起冲）



# Get

作用：根据用户指定的 `ReadOption` 和 `key` 找到符合条件的 SequenceNumber 最大（最新）的数据

接口：`Status DBImpl::Get(const ReadOptions& options, const Slice& key,std::string* value)`

整体过程概述：先找 memtable，再找 immutable memtable，再找 level0，和 leveln 的数据，level0 中的文件逆序之后需要遍历找（这是因为level0 中的数据 后面写的数据更新），其余层的数据先根据 larges key 找到可能存在 level 中可能存在的 sstfile，再拿到 file 对应 TableCache，先使用 filter(bloom filter) 查看对应的 key 是否可能存在，如果存在的话，再使用二分查找 datablock 中的数据，找不到就继续往下一层 level 中递归查找

过程：

* 首先将 memtable 互斥锁锁住，然后根据是否有快照，设定好 snapshot 能够看到的最大的 `SequenceNumber`，解锁对于 memtable 的互斥，因为这个时候查找 memtable 的时候已经知道了最大的 `SequenceNumber`，在一个只插入不删除不修改节点内容的 skiplist 中不会出现并发的问题（看到大于这个 SequenceNumber 就当看不见一样）
* 查找
  1. `mem->Get(lkey, value, &s)`在 memtable 中进行查找，直接利用 skiplist 的特点来进行加速查找

  > - 首先根据跳表的高度选取最高层的头节点；
  > - 若跳表中的节点内容小于查找节点的内容，则取该层的下一个节点继续比较；
  > - 若跳表中的节点内容等于查找节点的内容，则直接返回；
  > - 若跳表中的节点内容大于查找节点的内容，且层高不为0，则降低层高，且从前一个节点开始，重新查找低一层中的节点信息；若层高为0，则返回当前节点，该节点的key大于所查找节点的key。

  2. `imm->Get(lkey, value, &s)`，在 immutable memtable 中进行查找，查找的过程和 memtable 一样

  3. 如果还没找到，就要去 level file 中查找，

     这里细节非常的多，我觉得这里的细节还值得在挖掘，这里写出来我觉得非常重要而且清晰的点

     > 注意这个查找过程，简单来说：`ForEachOverlapping` 来查找每一层的 level file，level0 特殊处理（逆序查找），每一层会有很多的 levelfile，对于每一层，会先尝试使用 bloom filter 查看是否存在，如果可能存在，那么继续进行二分查找，下面详细说明每个部分的过程和作用
     >
     > * 遍历每一层的 sst file；
     >
     >   * 如果当前 SST（meta_data） 的 largest key 大于当前 key，这个时候有可能在当前的 file 中，然后再进行判断是否在当前的sst  file 中；
     >
     >   * 直接根据 sst file metadata 中存储的 smallest key 和 largest key 来找
     >
     >     * 现根据 largest 找到第一个大于 key 的本层的 file，下面，二分
     >
     >     * ```c++
     >       // 根据文件的 metadata 来二分查找，找到第一个大于 key 的 level file，如果不存在那么就会出现 right == files.size()
     >       int FindFile(const InternalKeyComparator& icmp,
     >                    const std::vector<FileMetaData*>& files, const Slice& key) {
     >         uint32_t left = 0;
     >         uint32_t right = files.size();
     >         while (left < right) {
     >           uint32_t mid = (left + right) / 2;
     >           const FileMetaData* f = files[mid];
     >           if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {
     >             // Key at "mid.largest" is < "target".  Therefore all
     >             // files at or before "mid" are uninteresting.
     >             left = mid + 1;
     >           } else {
     >             // Key at "mid.largest" is >= "target".  Therefore all files
     >             // after "mid" are uninteresting.
     >             right = mid;
     >           }
     >         }
     >         return right;
     >       }
     >       ```
     >
     >     * 然后根据 smallest 判断是否可能在当前的 file 中，如果可能再进行后面的步骤
     >
     >   * 这里有一个很重要的点，就是传入了一个参数作为之后匹配的点，叫做 `state::Match(void* arg, int level, FileMetaData* f)` 方法，这个方法中定义了之后如何在每一层的 sst file 中去找，也就是如何利用 sst file 的 metadata 来查找对应的 key；
     >
     >   * 这里的实现是 `TableCache::Get` 方法，首先会在 table cache 中去查找对应的 key，如果cache 中没有则打开文件（一个优化，提高读效率，这里是 lru cache），之后调用 `InternalGet` 方法在打开的 sst file 中查找对应的 key；
     >
     >   * 在 `Table::Internetget` 的时候会先尝试使用 `filter（bloom filter）`去查看对应的 key 是否可能存在，如果不存在就立即返回了
     >
     >   * 否则就会调用 Iterator（注意这里的 Iterator 是 class Block::Iter ） 的 seek 方法，所以是采用二分的方法在去找到对应的 key，一个朴素的 二分搜索，先找到**最大的小于 key 的某个值**，然后从这个值开始 linear search 找对应可能的 key
     >
     >   ```c++
     >   // db/block.cc class Block::Iter::Seek(args...)
     >   while (left < right) {
     >         uint32_t mid = (left + right + 1) / 2;
     >         uint32_t region_offset = GetRestartPoint(mid);
     >          // 因为 data block 会使用 共享前缀来压缩数据，所以需要计算出 restartpoint
     >          // 需要组合算出实际的 key，来和要对比的 user key 比较
     >         uint32_t shared, non_shared, value_length; 
     >         const char* key_ptr =
     >             DecodeEntry(data_ + region_offset, data_ + restarts_, &shared,
     >                         &non_shared, &value_length);  
     >         if (key_ptr == nullptr || (shared != 0)) {
     >           CorruptionError();
     >           return;
     >         }
     >         Slice mid_key(key_ptr, non_shared);
     >         if (Compare(mid_key, target) < 0) {
     >           // Key at "mid" is smaller than "target".  Therefore all
     >           // blocks before "mid" are uninteresting.
     >           left = mid;
     >         } else {
     >           // Key at "mid" is >= "target".  Therefore all blocks at or
     >           // after "mid" are uninteresting.
     >           right = mid - 1;
     >         }
     >       }
     >   
     >       // We might be able to use our current position within the restart block.
     >       // This is true if we determined the key we desire is in the current block
     >       // and is after than the current key.
     >       assert(current_key_compare == 0 || Valid());
     >       bool skip_seek = left == restart_index_ && current_key_compare < 0;
     >       if (!skip_seek) {
     >         SeekToRestartPoint(left);
     >       }
     >       // Linear search (within restart block) for first key >= target
     >       while (true) {
     >         if (!ParseNextKey()) {
     >           return;
     >         }
     >         if (Compare(key_, target) >= 0) {
     >           return;
     >         }
     >       }
     >   ```
     >
     >   * 最差的情况就是遍历完每一层都找不到，就返回找不到了，当然如果这个值被删除了（也就是有 delete 的存在，也返回找不到）

Get 的过程感觉还有非常多的细节可以挖，基本涉及到了整体 LSM 的整体结构，之后读完别的部分再回来补充，还是得多看代码，代码中的细节非常多，但是却又划分的十分清楚，真的写的太棒了！
