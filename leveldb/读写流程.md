[TOC]

# Put

作用：将指定的一个 KV 存储到 leveldb 中

过程（重要的步骤说明）：

* `DBImpl::Put(const WriteOptions& o, const Slice& key, const Slice& val)` 
  * 用户调用接口，会调用 
* `DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value)`
  * 这里会将单个的 Write 也改写成 WriteBatch 的形式，然后调用 `Write` 接口，`Write ` 接口是统一 leveldb 统一写操作的接口
* `DBImpl::Write(const WriteOptions& options, WriteBatch* updates)`
  * 会将写操作封装成一个 Writer 对象，然后这个地方会获取到一个 mutex lock，然后将当前的 Writer 加入到一个 deque 中去，由于拿到了 mutex，所以是**并发安全**的，这个入队列的操作是很快的，不需要真的写入
  * 很多 Writer 入队列之后都被加入到了末尾，所以这个这个循环条件是成立的，直到某个队列头的 Writer 出队列
  * 这个时候在 写队列头的 Writer 将负责这次写（这个 **首当其冲**的 Writer 任重道远）
    * 首先将调用 `MakeRoomForWrite`，检查 memtable 是否有足够的空间来写，可能有很多检查，例如当前是不是写的太快（是不是太多的 L0 文件，当前 memtable 没有足够空间且 immutable memtable 存在，甚至可能会手动调用 compaction），直到有一个足够空间的 memtable 来写
    * 调用 `BuildBatchGroup` 来将很多小的写入合成一个大的，这个很有讲究，因为不仅仅是将根据小的Writer 请求加起来的大小超过某个数值才写，还要看写入是否是 sync 的写入，如果是 sync 的写入，那么将直接写，因为要让用户马上返回不阻塞太久（不等别人），这个时候一些 non-sync 的 Writer 甚至可以搭上便车马上写入，但是如果一个非 sync 操作被搭车到一个 sync 操作的批次中，会使这个非 sync 的操作的延时给拖高。所以非同步的写要比同步的写快上几乎 1000 倍
    * 然后就是 `AddRecord` 写入，这个是写入到 log 中，详细看这个函数可以看到会将所有的数据分 block 来写，可以参考 https://leveldb-handbook.readthedocs.io/zh/latest/sstable.html#id2 来看对应的 data block 的接口，这里会实际的物理刷盘，WAL
    * 调用 `WriteBatchInternal::InsertInto(write_batch, mem_)`，写入到 memtable 中去，这是调表的插入，不在这里赘述
    * 设定 `Sequence`，这是用于 MVCC 的属性（TODO：MVCC 需要搞清楚 Sequence 的详细使用）
    * 负责将当前此次 WriteBatch 中的一条船上的 Writer 的 done 修改为 true，同时来唤醒他们，让他们都出队列，让下一个 **首当其冲** 的 Writer 来负责下一个写的重任（要带着兄弟萌一起冲）



# Get

// 回去再写